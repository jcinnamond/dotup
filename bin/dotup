#!/bin/bash

DOTUP_HOME=$HOME/.dotup
DOTFILE_DIR=$DOTUP_HOME/dotfiles

command=$1
command_arg=$2

DEBUGGING=$DEBUG || 0

function debug {
  if [ $DEBUGGING ]; then
    printf "DEBUG: $1"
  fi
}

function usage {
  progname=`basename $0`
  cat <<EOF
usage: $progname [command [options]]


COMMANDS:
  up       - setup or update the profile 
             (default if no command given)

  status   - warn about any updates or local modifications
             Add 'local' to only show modified files
             Add 'remote' to only show changes with origin
             (default is to show both)

  cleanup  - removes dangling symlinks to .dotup

  remove   - removes all symlinks to .dotup, restoring any original files
EOF
}

function check_command {
  command=$1
  which $command > /dev/null 2>&1
  status=$?
  if [ $status -ne 0 ]; then
    printf "Unmet dependency: you need to install $command\n"
    exit 1
  fi
}

function check_dependencies {
  check_command git
}

function is_setup {
  test -d $DOTUP_HOME
}

function link_files {
  files=`find $DOTFILE_DIR -type f`
  for path in $files; do
    dir=`dirname $path | sed -e "s|$DOTFILE_DIR||"`
    file=`basename $path`
    symlink_dest=$HOME$dir/$file

    # Backup existing files
    if [ -h $symlink_dest ]; then
      dest=`stat --format=%N $symlink_dest | sed -e "s/.*\\\`\(.*\)'$/\1/"`
      if [ $dest == $path ]; then
        debug "| $symlink_dest is already linked\n"
      else
        printf "$symlink_dest points somewhere else: skipping\n"
      fi
      continue
    elif [ -d $symlink_dest ]; then
      printf "can't install $symlink_dest: target already exists as a directory\n"
      continue
    elif [ -f $symlink_dest ]; then
      debug "& copying $symlink_dest to the restore directory\n"
      mkdir -p $DOTUP_HOME/restore/$dir
      cp $symlink_dest $DOTUP_HOME/restore/$dir
    fi

    debug "-> linking $path to $symlink_dest\n"

    if [ X$dir != X  -a ! -d $HOME/$dir ]; then
      mkdir -p $HOME/$dir
    fi

    ln -sf $path $symlink_dest
  done
}

function install {
  git clone git@github.com:jcinnamond/dotup.git $HOME/.dotup
  mkdir $HOME/bin
  ln -sf $DOTUP_HOME/bin/dotup $HOME/bin/dotup
}

function update {
  pushd $DOTUP_HOME > /dev/null
  git pull --quiet
  popd > /dev/null
  link_files
}

function up {
  check_dependencies
  pushd $HOME > /dev/null
  if is_setup; then
    printf "dotup updating\n"
    update
    printf "dotup finished\n"
  else
    printf "dotup installing"
    install
    printf "dotup finished\n"
  fi
  popd > /dev/null
}

function local_status {
  pushd $DOTUP_HOME > /dev/null
  git status -s
  popd > /dev/null
}

function remote_status {
  pushd $DOTUP_HOME > /dev/null
  git fetch > /dev/null 2>&1
  git_remote_changes='git log --no-merges --oneline ..origin/master'
  to_apply=`$git_remote_changes`
  if [ -n "$to_apply" ]; then
    printf "** Remote updates to apply\n"
    $git_remote_changes
    printf "\n"
  fi

  git_local_changes='git log --no-merges --oneline origin/master..'
  to_push=`$git_local_changes`
  if [ -n "$to_push" ]; then
    printf "** Changes not pushed to remote\n"
    $git_local_changes
    printf "\n"
  fi
  popd > /dev/null
}

function status {
  if [ X$command_arg == Xlocal ]; then
    local_status
  elif [ X$command_arg == Xremote ]; then
    remote_status
  else
    printf "Local changes\n\n"
    local_status
    printf "\n------------------------------------------------------------------------------\n"
    printf "\nRemote changes\n\n"
    remote_status
  fi
}

#------------------------------------------------------------------------------
# Argument processing
#------------------------------------------------------------------------------

if [ -z $command ]; then
  up
elif [ $command == "up" ]; then
  up
elif [ $command == "status" ]; then
  status
elif [ $command == "cleanup" ]; then
  printf "cleanup\n"
elif [ $command == "remove" ]; then
  printf "remove\n"
elif [ $command == "-h" -o $command == "help" ]; then
  usage
else
  printf "Unrecognised command: $command\n\n"
  usage
fi

